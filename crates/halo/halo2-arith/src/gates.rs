//! Gate implementations for Halo2 arithmetic circuits
//!
//! This module implements various types of gates that can be used to build
//! arithmetic circuits in the PLONK constraint system.

use crate::{Column, Constraint, Scalar, Result, AdviceColumn, FixedColumn};
use crate::constraints::Expression;

/// A gate that generates polynomial constraints
#[derive(Clone, Debug)]
pub struct Gate {
    /// Name of the gate (for debugging)
    pub name: String,
    /// Columns used by this gate
    pub columns: Vec<Column>,
    /// Polynomial constraints generated by this gate
    pub constraints: Vec<Constraint>,
    /// Whether this gate is enabled
    pub enabled: bool,
}

/// Standard arithmetic gate supporting addition and multiplication
#[derive(Clone, Debug)]
pub struct StandardGate {
    /// Left input column
    pub a: Column,
    /// Right input column
    pub b: Column,
    /// Output column
    pub c: Column,
    /// Selector column for addition
    pub q_add: Column,
    /// Selector column for multiplication
    pub q_mul: Column,
    /// Constant term selector
    pub q_const: Column,
}

/// Multiplication gate specifically for field multiplication
#[derive(Clone, Debug)]
pub struct MultiplicationGate {
    /// Left input
    pub a: Column,
    /// Right input
    pub b: Column,
    /// Output (a * b)
    pub c: Column,
    /// Selector
    pub q_mul: Column,
}

/// Addition gate for field addition
#[derive(Clone, Debug)]
pub struct AdditionGate {
    /// Left input
    pub a: Column,
    /// Right input
    pub b: Column,
    /// Output (a + b)
    pub c: Column,
    /// Selector
    pub q_add: Column,
}

/// Boolean constraint gate
#[derive(Clone, Debug)]
pub struct BooleanGate {
    /// The column that should contain boolean values (0 or 1)
    pub a: Column,
    /// Selector
    pub q_bool: Column,
}

/// Equality gate to enforce two columns are equal
#[derive(Clone, Debug)]
pub struct EqualityGate {
    /// First column
    pub a: Column,
    /// Second column
    pub b: Column,
    /// Selector
    pub q_eq: Column,
}

/// Custom gate with user-defined constraints
#[derive(Clone, Debug)]
pub struct CustomGate {
    /// Name of the custom gate
    pub name: String,
    /// Columns used by this gate
    pub columns: Vec<Column>,
    /// Custom constraint expressions
    pub expressions: Vec<Expression>,
    /// Selectors for enabling/disabling constraints
    pub selectors: Vec<Column>,
}

impl Gate {
    /// Create a new gate
    pub fn new(name: String, columns: Vec<Column>) -> Self {
        Self {
            name,
            columns,
            constraints: Vec::new(),
            enabled: true,
        }
    }

    /// Add a constraint to this gate
    pub fn add_constraint(&mut self, constraint: Constraint) {
        self.constraints.push(constraint);
    }

    /// Generate all constraints for this gate
    pub fn generate_constraints(&self) -> Result<Vec<Constraint>> {
        if !self.enabled {
            return Ok(Vec::new());
        }
        Ok(self.constraints.clone())
    }

    /// Enable or disable this gate
    pub fn set_enabled(&mut self, enabled: bool) {
        self.enabled = enabled;
    }
}

impl StandardGate {
    /// Create a new standard gate
    pub fn new(
        a: Column,
        b: Column, 
        c: Column,
        q_add: Column,
        q_mul: Column,
        q_const: Column,
    ) -> Self {
        Self { a, b, c, q_add, q_mul, q_const }
    }

    /// Generate constraints for the standard gate
    /// Constraint: q_add * (a + b - c) + q_mul * (a * b - c) + q_const * (const - c) = 0
    pub fn generate_constraints(&self) -> Result<Vec<Constraint>> {
        let mut constraints = Vec::new();

        // Addition constraint: q_add * (a + b - c) = 0
        let addition_expr = Expression::Product(
            Box::new(Expression::column(self.q_add.clone(), 0)),
            Box::new(Expression::Sum(
                Box::new(Expression::Sum(
                    Box::new(Expression::column(self.a.clone(), 0)),
                    Box::new(Expression::column(self.b.clone(), 0))
                )),
                Box::new(Expression::Negated(
                    Box::new(Expression::column(self.c.clone(), 0))
                ))
            ))
        );
        constraints.push(Constraint::new("standard_addition".to_string(), addition_expr));

        // Multiplication constraint: q_mul * (a * b - c) = 0
        let multiplication_expr = Expression::Product(
            Box::new(Expression::column(self.q_mul.clone(), 0)),
            Box::new(Expression::Sum(
                Box::new(Expression::Product(
                    Box::new(Expression::column(self.a.clone(), 0)),
                    Box::new(Expression::column(self.b.clone(), 0))
                )),
                Box::new(Expression::Negated(
                    Box::new(Expression::column(self.c.clone(), 0))
                ))
            ))
        );
        constraints.push(Constraint::new("standard_multiplication".to_string(), multiplication_expr));

        Ok(constraints)
    }

    /// Convert to generic gate
    pub fn into_gate(self) -> Result<Gate> {
        let columns = vec![self.a.clone(), self.b.clone(), self.c.clone(), 
                          self.q_add.clone(), self.q_mul.clone(), self.q_const.clone()];
        let mut gate = Gate::new("standard_gate".to_string(), columns);
        
        let constraints = self.generate_constraints()?;
        for constraint in constraints {
            gate.add_constraint(constraint);
        }
        
        Ok(gate)
    }
}

impl MultiplicationGate {
    /// Create a new multiplication gate
    pub fn new(a: Column, b: Column, c: Column, q_mul: Column) -> Self {
        Self { a, b, c, q_mul }
    }

    /// Generate constraint: q_mul * (a * b - c) = 0
    pub fn generate_constraints(&self) -> Result<Vec<Constraint>> {
        let expr = Expression::Product(
            Box::new(Expression::column(self.q_mul.clone(), 0)),
            Box::new(Expression::Sum(
                Box::new(Expression::Product(
                    Box::new(Expression::column(self.a.clone(), 0)),
                    Box::new(Expression::column(self.b.clone(), 0))
                )),
                Box::new(Expression::Negated(
                    Box::new(Expression::column(self.c.clone(), 0))
                ))
            ))
        );
        
        Ok(vec![Constraint::new("multiplication".to_string(), expr)])
    }

    /// Convert to generic gate
    pub fn into_gate(self) -> Result<Gate> {
        let columns = vec![self.a.clone(), self.b.clone(), self.c.clone(), self.q_mul.clone()];
        let mut gate = Gate::new("multiplication_gate".to_string(), columns);
        
        let constraints = self.generate_constraints()?;
        for constraint in constraints {
            gate.add_constraint(constraint);
        }
        
        Ok(gate)
    }
}

impl AdditionGate {
    /// Create a new addition gate
    pub fn new(a: Column, b: Column, c: Column, q_add: Column) -> Self {
        Self { a, b, c, q_add }
    }

    /// Generate constraint: q_add * (a + b - c) = 0
    pub fn generate_constraints(&self) -> Result<Vec<Constraint>> {
        let expr = Expression::Product(
            Box::new(Expression::column(self.q_add.clone(), 0)),
            Box::new(Expression::Sum(
                Box::new(Expression::Sum(
                    Box::new(Expression::column(self.a.clone(), 0)),
                    Box::new(Expression::column(self.b.clone(), 0))
                )),
                Box::new(Expression::Negated(
                    Box::new(Expression::column(self.c.clone(), 0))
                ))
            ))
        );
        
        Ok(vec![Constraint::new("addition".to_string(), expr)])
    }

    /// Convert to generic gate
    pub fn into_gate(self) -> Result<Gate> {
        let columns = vec![self.a.clone(), self.b.clone(), self.c.clone(), self.q_add.clone()];
        let mut gate = Gate::new("addition_gate".to_string(), columns);
        
        let constraints = self.generate_constraints()?;
        for constraint in constraints {
            gate.add_constraint(constraint);
        }
        
        Ok(gate)
    }
}

impl BooleanGate {
    /// Create a new boolean gate
    pub fn new(a: Column, q_bool: Column) -> Self {
        Self { a, q_bool }
    }

    /// Generate constraint: q_bool * a * (a - 1) = 0
    /// This enforces that a is either 0 or 1
    pub fn generate_constraints(&self) -> Result<Vec<Constraint>> {
        let expr = Expression::Product(
            Box::new(Expression::column(self.q_bool.clone(), 0)),
            Box::new(Expression::Product(
                Box::new(Expression::column(self.a.clone(), 0)),
                Box::new(Expression::Sum(
                    Box::new(Expression::column(self.a.clone(), 0)),
                    Box::new(Expression::Negated(
                        Box::new(Expression::constant(Scalar::one()))
                    ))
                ))
            ))
        );
        
        Ok(vec![Constraint::new("boolean".to_string(), expr)])
    }

    /// Convert to generic gate
    pub fn into_gate(self) -> Result<Gate> {
        let columns = vec![self.a.clone(), self.q_bool.clone()];
        let mut gate = Gate::new("boolean_gate".to_string(), columns);
        
        let constraints = self.generate_constraints()?;
        for constraint in constraints {
            gate.add_constraint(constraint);
        }
        
        Ok(gate)
    }
}

impl EqualityGate {
    /// Create a new equality gate
    pub fn new(a: Column, b: Column, q_eq: Column) -> Self {
        Self { a, b, q_eq }
    }

    /// Generate constraint: q_eq * (a - b) = 0
    pub fn generate_constraints(&self) -> Result<Vec<Constraint>> {
        let expr = Expression::Product(
            Box::new(Expression::column(self.q_eq.clone(), 0)),
            Box::new(Expression::Sum(
                Box::new(Expression::column(self.a.clone(), 0)),
                Box::new(Expression::Negated(
                    Box::new(Expression::column(self.b.clone(), 0))
                ))
            ))
        );
        
        Ok(vec![Constraint::new("equality".to_string(), expr)])
    }

    /// Convert to generic gate
    pub fn into_gate(self) -> Result<Gate> {
        let columns = vec![self.a.clone(), self.b.clone(), self.q_eq.clone()];
        let mut gate = Gate::new("equality_gate".to_string(), columns);
        
        let constraints = self.generate_constraints()?;
        for constraint in constraints {
            gate.add_constraint(constraint);
        }
        
        Ok(gate)
    }
}

impl CustomGate {
    /// Create a new custom gate
    pub fn new(name: String, columns: Vec<Column>, expressions: Vec<Expression>, selectors: Vec<Column>) -> Self {
        Self { name, columns, expressions, selectors }
    }

    /// Generate constraints from custom expressions
    pub fn generate_constraints(&self) -> Result<Vec<Constraint>> {
        let mut constraints = Vec::new();
        
        for (i, expr) in self.expressions.iter().enumerate() {
            let constraint_name = format!("{}_{}", self.name, i);
            
            // If we have selectors, multiply the expression by the selector
            let final_expr = if let Some(selector) = self.selectors.get(i) {
                Expression::Product(
                    Box::new(Expression::column(selector.clone(), 0)),
                    Box::new(expr.clone())
                )
            } else {
                expr.clone()
            };
            
            constraints.push(Constraint::new(constraint_name, final_expr));
        }
        
        Ok(constraints)
    }

    /// Convert to generic gate
    pub fn into_gate(self) -> Result<Gate> {
        let mut all_columns = self.columns.clone();
        all_columns.extend(self.selectors.clone());
        
        let mut gate = Gate::new(self.name.clone(), all_columns);
        
        let constraints = self.generate_constraints()?;
        for constraint in constraints {
            gate.add_constraint(constraint);
        }
        
        Ok(gate)
    }
}

/// Builder for creating standard gates easily
pub struct GateBuilder {
    advice_columns: Vec<AdviceColumn>,
    fixed_columns: Vec<FixedColumn>,
}

impl GateBuilder {
    /// Create a new gate builder
    pub fn new() -> Self {
        Self {
            advice_columns: Vec::new(),
            fixed_columns: Vec::new(),
        }
    }

    /// Add advice columns to the builder
    pub fn add_advice_columns(&mut self, count: usize) -> Vec<AdviceColumn> {
        let start_index = self.advice_columns.len();
        let mut new_columns = Vec::new();
        
        for i in 0..count {
            let column = AdviceColumn::new(start_index + i);
            self.advice_columns.push(column.clone());
            new_columns.push(column);
        }
        
        new_columns
    }

    /// Add fixed columns to the builder
    pub fn add_fixed_columns(&mut self, count: usize) -> Vec<FixedColumn> {
        let start_index = self.fixed_columns.len();
        let mut new_columns = Vec::new();
        
        for i in 0..count {
            let column = FixedColumn::new(start_index + i);
            self.fixed_columns.push(column.clone());
            new_columns.push(column);
        }
        
        new_columns
    }

    /// Build a standard arithmetic gate
    pub fn build_standard_gate(&mut self) -> Result<StandardGate> {
        let advice = self.add_advice_columns(3); // a, b, c
        let fixed = self.add_fixed_columns(3);   // q_add, q_mul, q_const
        
        Ok(StandardGate::new(
            Column::Advice(advice[0].clone()),
            Column::Advice(advice[1].clone()),
            Column::Advice(advice[2].clone()),
            Column::Fixed(fixed[0].clone()),
            Column::Fixed(fixed[1].clone()),
            Column::Fixed(fixed[2].clone()),
        ))
    }

    /// Build a multiplication gate
    pub fn build_multiplication_gate(&mut self) -> Result<MultiplicationGate> {
        let advice = self.add_advice_columns(3); // a, b, c
        let fixed = self.add_fixed_columns(1);   // q_mul
        
        Ok(MultiplicationGate::new(
            Column::Advice(advice[0].clone()),
            Column::Advice(advice[1].clone()),
            Column::Advice(advice[2].clone()),
            Column::Fixed(fixed[0].clone()),
        ))
    }
}

impl Default for GateBuilder {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bls12_381::Scalar as BlsScalar;
    use ff::Field;
    use std::collections::HashMap;

    #[test]
    fn test_standard_gate_creation() {
        let mut builder = GateBuilder::new();
        let gate = builder.build_standard_gate().unwrap();
        
        let constraints = gate.generate_constraints().unwrap();
        assert_eq!(constraints.len(), 2); // addition and multiplication constraints
    }

    #[test]
    fn test_multiplication_gate() {
        let a = Column::Advice(AdviceColumn::new(0));
        let b = Column::Advice(AdviceColumn::new(1));
        let c = Column::Advice(AdviceColumn::new(2));
        let q_mul = Column::Fixed(FixedColumn::new(0));
        
        let gate = MultiplicationGate::new(a, b, c, q_mul);
        let constraints = gate.generate_constraints().unwrap();
        
        assert_eq!(constraints.len(), 1);
        assert_eq!(constraints[0].name, "multiplication");
    }

    #[test]
    fn test_boolean_gate() {
        let a = Column::Advice(AdviceColumn::new(0));
        let q_bool = Column::Fixed(FixedColumn::new(0));
        
        let gate = BooleanGate::new(a, q_bool);
        let constraints = gate.generate_constraints().unwrap();
        
        assert_eq!(constraints.len(), 1);
        assert_eq!(constraints[0].name, "boolean");
    }

    #[test]
    fn test_custom_gate() {
        let a = Column::Advice(AdviceColumn::new(0));
        let b = Column::Advice(AdviceColumn::new(1));
        let selector = Column::Fixed(FixedColumn::new(0));
        
        let expr = Expression::Sum(
            Box::new(Expression::column(a.clone(), 0)),
            Box::new(Expression::column(b.clone(), 0))
        );
        
        let gate = CustomGate::new(
            "custom_addition".to_string(),
            vec![a, b],
            vec![expr],
            vec![selector]
        );
        
        let constraints = gate.generate_constraints().unwrap();
        assert_eq!(constraints.len(), 1);
        assert_eq!(constraints[0].name, "custom_addition_0");
    }

    #[test]
    fn test_equality_gate() {
        let a = Column::Advice(AdviceColumn::new(0));
        let b = Column::Advice(AdviceColumn::new(1));
        let q_eq = Column::Fixed(FixedColumn::new(0));
        
        let gate = EqualityGate::new(a, b, q_eq);
        let constraints = gate.generate_constraints().unwrap();
        
        assert_eq!(constraints.len(), 1);
        assert_eq!(constraints[0].name, "equality");
    }

    #[test]
    fn test_gate_builder() {
        let mut builder = GateBuilder::new();
        
        let advice_cols = builder.add_advice_columns(2);
        let fixed_cols = builder.add_fixed_columns(1);
        
        assert_eq!(advice_cols.len(), 2);
        assert_eq!(fixed_cols.len(), 1);
        assert_eq!(advice_cols[0].index, 0);
        assert_eq!(advice_cols[1].index, 1);
        assert_eq!(fixed_cols[0].index, 0);
    }
}
