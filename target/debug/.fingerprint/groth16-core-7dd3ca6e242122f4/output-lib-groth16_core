{"$message_type":"diagnostic","message":"unused import: `Group`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":444,"byte_end":449,"line_start":14,"line_end":14,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"use ark_ec::{CurveGroup, Group, AffineRepr, VariableBaseMSM, pairing::Pairing};","highlight_start":26,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":442,"byte_end":449,"line_start":14,"line_end":14,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"use ark_ec::{CurveGroup, Group, AffineRepr, VariableBaseMSM, pairing::Pairing};","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `Group`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:14:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse ark_ec::{CurveGroup, Group, AffineRepr, VariableBaseMSM, pairing::Pairing};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":2671,"byte_end":2674,"line_start":88,"line_end":88,"column_start":57,"column_end":60,"is_primary":true,"text":[{"text":"        if assignment.is_empty() || assignment[0] != F::one() {","highlight_start":57,"highlight_end":60}],"label":"multiple `one` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `FieldLike`","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/zero-knowledge-proofs/zero-knowledge-proofs/crates/groth16-field/src/lib.rs","byte_start":1155,"byte_end":1171,"line_start":40,"line_end":40,"column_start":5,"column_end":21,"is_primary":true,"text":[{"text":"    fn one() -> Self {","highlight_start":5,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `One`","code":null,"level":"note","spans":[{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/identities.rs","byte_start":2688,"byte_end":2705,"line_start":115,"line_end":115,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"    fn one() -> Self;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":2668,"byte_end":2671,"line_start":88,"line_end":88,"column_start":54,"column_end":57,"is_primary":true,"text":[{"text":"        if assignment.is_empty() || assignment[0] != F::one() {","highlight_start":54,"highlight_end":57}],"label":null,"suggested_replacement":"<F as FieldLike>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":2668,"byte_end":2671,"line_start":88,"line_end":88,"column_start":54,"column_end":57,"is_primary":true,"text":[{"text":"        if assignment.is_empty() || assignment[0] != F::one() {","highlight_start":54,"highlight_end":57}],"label":null,"suggested_replacement":"<F as One>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:88:57\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if assignment.is_empty() || assignment[0] != F::one() {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `one` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `FieldLike`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/runner/work/zero-knowledge-proofs/zero-knowledge-proofs/crates/groth16-field/src/lib.rs:40:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn one() -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `One`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/identities.rs:115:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn one() -> Self;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        if assignment.is_empty() || assignment[0] != \u001b[0m\u001b[0m\u001b[38;5;9mF::\u001b[0m\u001b[0mone() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        if assignment.is_empty() || assignment[0] != \u001b[0m\u001b[0m\u001b[38;5;10m<F as FieldLike>::\u001b[0m\u001b[0mone() {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        if assignment.is_empty() || assignment[0] != \u001b[0m\u001b[0m\u001b[38;5;9mF::\u001b[0m\u001b[0mone() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        if assignment.is_empty() || assignment[0] != \u001b[0m\u001b[0m\u001b[38;5;10m<F as One>::\u001b[0m\u001b[0mone() {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `group_gen` found for struct `ark_poly::domain::radix2::Radix2EvaluationDomain` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":3685,"byte_end":3694,"line_start":120,"line_end":120,"column_start":32,"column_end":41,"is_primary":true,"text":[{"text":"        let omega = qap.domain.group_gen();","highlight_start":32,"highlight_end":41}],"label":"field, not a method","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-poly-0.4.2/src/domain/mod.rs","byte_start":2783,"byte_end":2792,"line_start":77,"line_end":77,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"    fn group_gen(&self) -> F;","highlight_start":8,"highlight_end":17}],"label":"the method is available for `ark_poly::domain::radix2::Radix2EvaluationDomain<F>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"remove the arguments","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":3694,"byte_end":3696,"line_start":120,"line_end":120,"column_start":41,"column_end":43,"is_primary":true,"text":[{"text":"        let omega = qap.domain.group_gen();","highlight_start":41,"highlight_end":43}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"trait `EvaluationDomain` which provides `group_gen` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":293,"byte_end":293,"line_start":10,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use groth16_field::FieldLike;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use ark_poly::domain::EvaluationDomain;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `group_gen_inv` with a similar name","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":3685,"byte_end":3694,"line_start":120,"line_end":120,"column_start":32,"column_end":41,"is_primary":true,"text":[{"text":"        let omega = qap.domain.group_gen();","highlight_start":32,"highlight_end":41}],"label":null,"suggested_replacement":"group_gen_inv","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `group_gen` found for struct `ark_poly::domain::radix2::Radix2EvaluationDomain` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:120:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let omega = qap.domain.group_gen();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfield, not a method\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-poly-0.4.2/src/domain/mod.rs:77:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn group_gen(&self) -> F;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `ark_poly::domain::radix2::Radix2EvaluationDomain<F>` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        let omega = qap.domain.group_gen\u001b[0m\u001b[0m\u001b[38;5;9m()\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        let omega = qap.domain.group_gen;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `EvaluationDomain` which provides `group_gen` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use ark_poly::domain::EvaluationDomain;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `group_gen_inv` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let omega = qap.domain.group_gen\u001b[0m\u001b[0m\u001b[38;5;10m_inv\u001b[0m\u001b[0m();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":4983,"byte_end":4986,"line_start":166,"line_end":166,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"        a_contributions.push((Fr::one(), pk.alpha_g1));","highlight_start":35,"highlight_end":38}],"label":"multiple `one` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":4979,"byte_end":4983,"line_start":166,"line_end":166,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"        a_contributions.push((Fr::one(), pk.alpha_g1));","highlight_start":31,"highlight_end":35}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":4979,"byte_end":4983,"line_start":166,"line_end":166,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"        a_contributions.push((Fr::one(), pk.alpha_g1));","highlight_start":31,"highlight_end":35}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:166:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        a_contributions.push((Fr::one(), pk.alpha_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `one` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        a_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), pk.alpha_g1));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        a_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::\u001b[0m\u001b[0mone(), pk.alpha_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        a_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), pk.alpha_g1));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        a_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::\u001b[0m\u001b[0mone(), pk.alpha_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":5615,"byte_end":5618,"line_start":184,"line_end":184,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"        b_contributions.push((Fr::one(), pk.beta_g2));","highlight_start":35,"highlight_end":38}],"label":"multiple `one` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":5611,"byte_end":5615,"line_start":184,"line_end":184,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"        b_contributions.push((Fr::one(), pk.beta_g2));","highlight_start":31,"highlight_end":35}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":5611,"byte_end":5615,"line_start":184,"line_end":184,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"        b_contributions.push((Fr::one(), pk.beta_g2));","highlight_start":31,"highlight_end":35}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:184:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        b_contributions.push((Fr::one(), pk.beta_g2));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `one` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        b_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), pk.beta_g2));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        b_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::\u001b[0m\u001b[0mone(), pk.beta_g2));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        b_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), pk.beta_g2));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        b_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::\u001b[0m\u001b[0mone(), pk.beta_g2));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `coeffs` found for struct `ark_poly::polynomial::univariate::dense::DensePolynomial<F>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":6292,"byte_end":6298,"line_start":202,"line_end":202,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"        let h_coeffs: Vec<Fr> = h_poly.coeffs().iter()","highlight_start":40,"highlight_end":46}],"label":"field, not a method","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-poly-0.4.2/src/polynomial/mod.rs","byte_start":1387,"byte_end":1393,"line_start":51,"line_end":51,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn coeffs(&self) -> &[F];","highlight_start":8,"highlight_end":14}],"label":"the method is available for `ark_poly::polynomial::univariate::dense::DensePolynomial<F>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"remove the arguments","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":6298,"byte_end":6300,"line_start":202,"line_end":202,"column_start":46,"column_end":48,"is_primary":true,"text":[{"text":"        let h_coeffs: Vec<Fr> = h_poly.coeffs().iter()","highlight_start":46,"highlight_end":48}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"trait `DenseUVPolynomial` which provides `coeffs` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":293,"byte_end":293,"line_start":10,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use groth16_field::FieldLike;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use ark_poly::polynomial::DenseUVPolynomial;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `coeffs` found for struct `ark_poly::polynomial::univariate::dense::DensePolynomial<F>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:202:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h_coeffs: Vec<Fr> = h_poly.coeffs().iter()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfield, not a method\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-poly-0.4.2/src/polynomial/mod.rs:51:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn coeffs(&self) -> &[F];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `ark_poly::polynomial::univariate::dense::DensePolynomial<F>` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        let h_coeffs: Vec<Fr> = h_poly.coeffs\u001b[0m\u001b[0m\u001b[38;5;9m()\u001b[0m\u001b[0m.iter()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        let h_coeffs: Vec<Fr> = h_poly.coeffs.iter()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `DenseUVPolynomial` which provides `coeffs` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use ark_poly::polynomial::DenseUVPolynomial;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":7625,"byte_end":7628,"line_start":235,"line_end":235,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"            c_contributions.push((Fr::one(), h_s_g1));","highlight_start":39,"highlight_end":42}],"label":"multiple `one` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":7621,"byte_end":7625,"line_start":235,"line_end":235,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"            c_contributions.push((Fr::one(), h_s_g1));","highlight_start":35,"highlight_end":39}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":7621,"byte_end":7625,"line_start":235,"line_end":235,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"            c_contributions.push((Fr::one(), h_s_g1));","highlight_start":35,"highlight_end":39}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:235:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c_contributions.push((Fr::one(), h_s_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `one` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m            c_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), h_s_g1));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m            c_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::\u001b[0m\u001b[0mone(), h_s_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m            c_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), h_s_g1));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m            c_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::\u001b[0m\u001b[0mone(), h_s_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":8015,"byte_end":8018,"line_start":246,"line_end":246,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"        b1_contributions.push((Fr::one(), pk.beta_g1));","highlight_start":36,"highlight_end":39}],"label":"multiple `one` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":8011,"byte_end":8015,"line_start":246,"line_end":246,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"        b1_contributions.push((Fr::one(), pk.beta_g1));","highlight_start":32,"highlight_end":36}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":8011,"byte_end":8015,"line_start":246,"line_end":246,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"        b1_contributions.push((Fr::one(), pk.beta_g1));","highlight_start":32,"highlight_end":36}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:246:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        b1_contributions.push((Fr::one(), pk.beta_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `one` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        b1_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), pk.beta_g1));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        b1_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::\u001b[0m\u001b[0mone(), pk.beta_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        b1_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), pk.beta_g1));\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        b1_contributions.push((\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::\u001b[0m\u001b[0mone(), pk.beta_g1));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":10840,"byte_end":10843,"line_start":331,"line_end":331,"column_start":67,"column_end":70,"is_primary":true,"text":[{"text":"        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];","highlight_start":67,"highlight_end":70}],"label":"multiple `one` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":10836,"byte_end":10840,"line_start":331,"line_end":331,"column_start":63,"column_end":67,"is_primary":true,"text":[{"text":"        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];","highlight_start":63,"highlight_end":67}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":10836,"byte_end":10840,"line_start":331,"line_end":331,"column_start":63,"column_end":67,"is_primary":true,"text":[{"text":"        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];","highlight_start":63,"highlight_end":67}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:331:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `one` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `G1Prepared<Config>: From<(Affine<Config>, Affine<Config>)>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":11757,"byte_end":11766,"line_start":355,"line_end":355,"column_start":22,"column_end":31,"is_primary":true,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":22,"highlight_end":31}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `From<(ark_ec::short_weierstrass::Affine<ark_bls12_381::g1::Config>, ark_ec::short_weierstrass::Affine<ark_bls12_381::g2::Config>)>` is not implemented for `ark_ec::bls12::G1Prepared<ark_bls12_381::Config>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\n  `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`\n  `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\n  `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(Affine<Config>, Affine<Config>)` to implement `Into<ark_ec::bls12::G1Prepared<ark_bls12_381::Config>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `multi_pairing`","code":null,"level":"note","spans":[{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs","byte_start":3503,"byte_end":3516,"line_start":103,"line_end":103,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"    fn multi_pairing(","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs","byte_start":3559,"byte_end":3581,"line_start":104,"line_end":104,"column_start":42,"column_end":64,"is_primary":true,"text":[{"text":"        a: impl IntoIterator<Item = impl Into<Self::G1Prepared>>,","highlight_start":42,"highlight_end":64}],"label":"required by this bound in `Pairing::multi_pairing`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/runner/work/zero-knowledge-proofs/zero-knowledge-proofs/target/debug/deps/groth16_core-7dd3ca6e242122f4.long-type-17960438968842851369.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `G1Prepared<Config>: From<(Affine<Config>, Affine<Config>)>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:355:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m355\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let result = Bls12_381::multi_pairing(pairing_inputs);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `From<(ark_ec::short_weierstrass::Affine<ark_bls12_381::g1::Config>, ark_ec::short_weierstrass::Affine<ark_bls12_381::g2::Config>)>` is not implemented for `ark_ec::bls12::G1Prepared<ark_bls12_381::Config>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `(Affine<Config>, Affine<Config>)` to implement `Into<ark_ec::bls12::G1Prepared<ark_bls12_381::Config>>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `multi_pairing`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs:104:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn multi_pairing(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        a: impl IntoIterator<Item = impl Into<Self::G1Prepared>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Pairing::multi_pairing`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/runner/work/zero-knowledge-proofs/zero-knowledge-proofs/target/debug/deps/groth16_core-7dd3ca6e242122f4.long-type-17960438968842851369.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":11781,"byte_end":11797,"line_start":355,"line_end":355,"column_start":46,"column_end":62,"is_primary":false,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":46,"highlight_end":62}],"label":"argument #2 is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":11757,"byte_end":11781,"line_start":355,"line_end":355,"column_start":22,"column_end":46,"is_primary":true,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":22,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs","byte_start":3503,"byte_end":3516,"line_start":103,"line_end":103,"column_start":8,"column_end":21,"is_primary":true,"text":[{"text":"    fn multi_pairing(","highlight_start":8,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":11781,"byte_end":11797,"line_start":355,"line_end":355,"column_start":46,"column_end":62,"is_primary":true,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":46,"highlight_end":62}],"label":null,"suggested_replacement":"(pairing_inputs, /* b */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 2 arguments but 1 argument was supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:355:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m355\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let result = Bls12_381::multi_pairing(pairing_inputs);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument #2 is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs:103:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn multi_pairing(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m355\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let result = Bls12_381::multi_pairing(pairing_inputs\u001b[0m\u001b[0m\u001b[38;5;10m, /* b */\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":13764,"byte_end":13767,"line_start":412,"line_end":412,"column_start":71,"column_end":74,"is_primary":true,"text":[{"text":"            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];","highlight_start":71,"highlight_end":74}],"label":"multiple `one` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":13760,"byte_end":13764,"line_start":412,"line_end":412,"column_start":67,"column_end":71,"is_primary":true,"text":[{"text":"            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];","highlight_start":67,"highlight_end":71}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":13760,"byte_end":13764,"line_start":412,"line_end":412,"column_start":67,"column_end":71,"is_primary":true,"text":[{"text":"            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];","highlight_start":67,"highlight_end":71}],"label":null,"suggested_replacement":"<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:412:71\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(Fr::one(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `one` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #1 is defined in an impl of the trait `FieldLike` for the type `ark_ff::Fp<MontBackend<FrConfig, 4>, 4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: candidate #2 is defined in an impl of the trait `One` for the type `ark_ff::Fp<P, N>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use fully-qualified syntax to disambiguate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as FieldLike>::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;9mFr::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m            let mut ic_contributions: Vec<(Fr, G1Affine)> = vec![(\u001b[0m\u001b[0m\u001b[38;5;10m<ark_ff::Fp<MontBackend<FrConfig, 4>, 4> as One>::\u001b[0m\u001b[0mone(), vk.ic_g1[0])];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `G1Prepared<Config>: From<(Affine<Config>, Affine<Config>)>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":14630,"byte_end":14639,"line_start":436,"line_end":436,"column_start":22,"column_end":31,"is_primary":true,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":22,"highlight_end":31}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `From<(ark_ec::short_weierstrass::Affine<ark_bls12_381::g1::Config>, ark_ec::short_weierstrass::Affine<ark_bls12_381::g2::Config>)>` is not implemented for `ark_ec::bls12::G1Prepared<ark_bls12_381::Config>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\n  `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`\n  `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\n  `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(Affine<Config>, Affine<Config>)` to implement `Into<ark_ec::bls12::G1Prepared<ark_bls12_381::Config>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `multi_pairing`","code":null,"level":"note","spans":[{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs","byte_start":3503,"byte_end":3516,"line_start":103,"line_end":103,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"    fn multi_pairing(","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs","byte_start":3559,"byte_end":3581,"line_start":104,"line_end":104,"column_start":42,"column_end":64,"is_primary":true,"text":[{"text":"        a: impl IntoIterator<Item = impl Into<Self::G1Prepared>>,","highlight_start":42,"highlight_end":64}],"label":"required by this bound in `Pairing::multi_pairing`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/runner/work/zero-knowledge-proofs/zero-knowledge-proofs/target/debug/deps/groth16_core-7dd3ca6e242122f4.long-type-17960438968842851369.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `G1Prepared<Config>: From<(Affine<Config>, Affine<Config>)>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:436:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m436\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let result = Bls12_381::multi_pairing(pairing_inputs);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `From<(ark_ec::short_weierstrass::Affine<ark_bls12_381::g1::Config>, ark_ec::short_weierstrass::Affine<ark_bls12_381::g2::Config>)>` is not implemented for `ark_ec::bls12::G1Prepared<ark_bls12_381::Config>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<&ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Affine<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m              `ark_ec::bls12::G1Prepared<P>` implements `From<ark_ec::short_weierstrass::Projective<<P as Bls12Config>::G1Config>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `(Affine<Config>, Affine<Config>)` to implement `Into<ark_ec::bls12::G1Prepared<ark_bls12_381::Config>>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `multi_pairing`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs:104:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn multi_pairing(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        a: impl IntoIterator<Item = impl Into<Self::G1Prepared>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Pairing::multi_pairing`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/runner/work/zero-knowledge-proofs/zero-knowledge-proofs/target/debug/deps/groth16_core-7dd3ca6e242122f4.long-type-17960438968842851369.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":14654,"byte_end":14670,"line_start":436,"line_end":436,"column_start":46,"column_end":62,"is_primary":false,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":46,"highlight_end":62}],"label":"argument #2 is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/groth16-core/src/lib.rs","byte_start":14630,"byte_end":14654,"line_start":436,"line_end":436,"column_start":22,"column_end":46,"is_primary":true,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":22,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs","byte_start":3503,"byte_end":3516,"line_start":103,"line_end":103,"column_start":8,"column_end":21,"is_primary":true,"text":[{"text":"    fn multi_pairing(","highlight_start":8,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":14654,"byte_end":14670,"line_start":436,"line_end":436,"column_start":46,"column_end":62,"is_primary":true,"text":[{"text":"        let result = Bls12_381::multi_pairing(pairing_inputs);","highlight_start":46,"highlight_end":62}],"label":null,"suggested_replacement":"(pairing_inputs, /* b */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 2 arguments but 1 argument was supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:436:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m436\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let result = Bls12_381::multi_pairing(pairing_inputs);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument #2 is missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-ec-0.4.2/src/pairing.rs:103:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn multi_pairing(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m436\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let result = Bls12_381::multi_pairing(pairing_inputs\u001b[0m\u001b[0m\u001b[38;5;10m, /* b */\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `AffineRepr`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/groth16-core/src/lib.rs","byte_start":451,"byte_end":461,"line_start":14,"line_end":14,"column_start":33,"column_end":43,"is_primary":true,"text":[{"text":"use ark_ec::{CurveGroup, Group, AffineRepr, VariableBaseMSM, pairing::Pairing};","highlight_start":33,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `AffineRepr`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/groth16-core/src/lib.rs:14:33\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse ark_ec::{CurveGroup, Group, AffineRepr, VariableBaseMSM, pairing::Pairing};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 13 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 13 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0034, E0061, E0277, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0034, E0061, E0277, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0034`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0034`.\u001b[0m\n"}
